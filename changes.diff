diff --git a/crates/ty_python_semantic/src/types.rs b/crates/ty_python_semantic/src/types.rs
index 1c14cf6d1..1237ade09 100644
--- a/crates/ty_python_semantic/src/types.rs
+++ b/crates/ty_python_semantic/src/types.rs
@@ -1258,26 +1258,59 @@ impl<'db> Type<'db> {
     }
 
     fn has_relation_to(self, db: &'db dyn Db, target: Type<'db>, relation: TypeRelation) -> bool {
+        self.try_has_relation_to(db, target, relation).is_ok()
+    }
+
+    pub(crate) fn try_is_subtype_of(
+        self,
+        db: &'db dyn Db,
+        target: Type<'db>,
+    ) -> Result<(), TypeRelationError> {
+        self.try_has_relation_to(db, target, TypeRelation::Subtyping)
+    }
+
+    pub(crate) fn try_is_assignable_to(
+        self,
+        db: &'db dyn Db,
+        target: Type<'db>,
+    ) -> Result<(), TypeRelationError> {
+        self.try_has_relation_to(db, target, TypeRelation::Assignability)
+    }
+
+    fn try_has_relation_to(
+        self,
+        db: &'db dyn Db,
+        target: Type<'db>,
+        relation: TypeRelation,
+    ) -> Result<(), TypeRelationError> {
         // Subtyping implies assignability, so if subtyping is reflexive and the two types are
         // equal, it is both a subtype and assignable. Assignability is always reflexive.
         //
         // Note that we could do a full equivalence check here, but that would be both expensive
         // and unnecessary. This early return is only an optimisation.
         if (relation.is_assignability() || self.subtyping_is_always_reflexive()) && self == target {
-            return true;
+            return Ok(());
         }
 
         match (self, target) {
             // Everything is a subtype of `object`.
-            (_, Type::NominalInstance(instance)) if instance.class.is_object(db) => true,
+            (_, Type::NominalInstance(instance)) if instance.class.is_object(db) => Ok(()),
 
             // `Never` is the bottom type, the empty set.
             // It is a subtype of all other types.
-            (Type::Never, _) => true,
+            (Type::Never, _) => Ok(()),
 
             // Dynamic is only a subtype of `object` and only a supertype of `Never`; both were
             // handled above. It's always assignable, though.
-            (Type::Dynamic(_), _) | (_, Type::Dynamic(_)) => relation.is_assignability(),
+            (Type::Dynamic(_), _) | (_, Type::Dynamic(_)) => {
+                if relation.is_assignability() {
+                    Ok(())
+                } else {
+                    Err(TypeRelationError::single(
+                        TypeRelationErrorKind::GradualTypeInSubTyping,
+                    ))
+                }
+            }
 
             // Pretend that instances of `dataclasses.Field` are assignable to their default type.
             // This allows field definitions like `name: str = field(default="")` in dataclasses
@@ -1285,7 +1318,9 @@ impl<'db> Type<'db> {
             (Type::KnownInstance(KnownInstanceType::Field(field)), right)
                 if relation.is_assignability() =>
             {
-                field.default_type(db).has_relation_to(db, right, relation)
+                field
+                    .default_type(db)
+                    .try_has_relation_to(db, right, relation)
             }
 
             // In general, a TypeVar `T` is not a subtype of a type `S` unless one of the two conditions is satisfied:
@@ -1296,16 +1331,16 @@ impl<'db> Type<'db> {
             // However, there is one exception to this general rule: for any given typevar `T`,
             // `T` will always be a subtype of any union containing `T`.
             // A similar rule applies in reverse to intersection types.
-            (Type::TypeVar(_), Type::Union(union)) if union.elements(db).contains(&self) => true,
+            (Type::TypeVar(_), Type::Union(union)) if union.elements(db).contains(&self) => Ok(()),
             (Type::Intersection(intersection), Type::TypeVar(_))
                 if intersection.positive(db).contains(&target) =>
             {
-                true
+                Ok(())
             }
             (Type::Intersection(intersection), Type::TypeVar(_))
                 if intersection.negative(db).contains(&target) =>
             {
-                false
+                Err(TypeRelationError::todo())
             }
 
             // Two identical typevars must always solve to the same type, so they are always
@@ -1316,7 +1351,7 @@ impl<'db> Type<'db> {
             (Type::TypeVar(lhs_typevar), Type::TypeVar(rhs_typevar))
                 if lhs_typevar == rhs_typevar =>
             {
-                true
+                Ok(())
             }
 
             // A fully static typevar is a subtype of its upper bound, and to something similar to
@@ -1326,12 +1361,21 @@ impl<'db> Type<'db> {
                 match typevar.bound_or_constraints(db) {
                     None => unreachable!(),
                     Some(TypeVarBoundOrConstraints::UpperBound(bound)) => {
-                        bound.has_relation_to(db, target, relation)
+                        bound.try_has_relation_to(db, target, relation)
+                    }
+                    Some(TypeVarBoundOrConstraints::Constraints(constraints)) => {
+                        let results = constraints
+                            .elements(db)
+                            .iter()
+                            .map(|constraint| constraint.try_has_relation_to(db, target, relation))
+                            .collect::<Vec<_>>();
+
+                        if results.iter().all(Result::is_ok) {
+                            Ok(())
+                        } else {
+                            TypeRelationError::from_results(results)
+                        }
                     }
-                    Some(TypeVarBoundOrConstraints::Constraints(constraints)) => constraints
-                        .elements(db)
-                        .iter()
-                        .all(|constraint| constraint.has_relation_to(db, target, relation)),
                 }
             }
 
@@ -1345,57 +1389,111 @@ impl<'db> Type<'db> {
                         .all(|constraint| self.has_relation_to(db, *constraint, relation))
                 }) =>
             {
-                true
+                Ok(())
             }
 
             // `Never` is the bottom type, the empty set.
             // Other than one unlikely edge case (TypeVars bound to `Never`),
             // no other type is a subtype of or assignable to `Never`.
-            (_, Type::Never) => false,
+            (_, Type::Never) => Err(TypeRelationError::todo()),
 
-            (Type::Union(union), _) => union
-                .elements(db)
-                .iter()
-                .all(|&elem_ty| elem_ty.has_relation_to(db, target, relation)),
+            (Type::Union(union), _) => {
+                let results = union
+                    .elements(db)
+                    .iter()
+                    .map(|&elem_ty| elem_ty.try_has_relation_to(db, target, relation))
+                    .collect::<Vec<_>>();
 
-            (_, Type::Union(union)) => union
-                .elements(db)
-                .iter()
-                .any(|&elem_ty| self.has_relation_to(db, elem_ty, relation)),
+                if results.iter().all(Result::is_ok) {
+                    Ok(())
+                } else {
+                    TypeRelationError::from_results(results)
+                }
+            }
+
+            (_, Type::Union(union)) => {
+                let results = union
+                    .elements(db)
+                    .iter()
+                    .map(|&elem_ty| self.try_has_relation_to(db, elem_ty, relation))
+                    .collect::<Vec<_>>();
+
+                if results.iter().any(Result::is_ok) {
+                    Ok(())
+                } else {
+                    TypeRelationError::from_results(results)
+                }
+            }
 
             // If both sides are intersections we need to handle the right side first
             // (A & B & C) is a subtype of (A & B) because the left is a subtype of both A and B,
             // but none of A, B, or C is a subtype of (A & B).
             (_, Type::Intersection(intersection)) => {
-                intersection
+                let results = intersection
                     .positive(db)
                     .iter()
-                    .all(|&pos_ty| self.has_relation_to(db, pos_ty, relation))
-                    && intersection
+                    .map(|&pos_ty| self.try_has_relation_to(db, pos_ty, relation))
+                    .collect::<Vec<_>>();
+
+                if results.iter().all(Result::is_ok) {
+                    if intersection
                         .negative(db)
                         .iter()
                         .all(|&neg_ty| self.is_disjoint_from(db, neg_ty))
+                    {
+                        Ok(())
+                    } else {
+                        Err(TypeRelationError::todo())
+                    }
+                } else {
+                    TypeRelationError::from_results(results)
+                }
             }
 
-            (Type::Intersection(intersection), _) => intersection
-                .positive(db)
-                .iter()
-                .any(|&elem_ty| elem_ty.has_relation_to(db, target, relation)),
+            (Type::Intersection(intersection), _) => {
+                let results = intersection
+                    .positive(db)
+                    .iter()
+                    .map(|&elem_ty| elem_ty.try_has_relation_to(db, target, relation))
+                    .collect::<Vec<_>>();
+
+                if results.iter().any(Result::is_ok) {
+                    Ok(())
+                } else {
+                    TypeRelationError::from_results(results)
+                }
+            }
 
             // Other than the special cases checked above, no other types are a subtype of a
             // typevar, since there's no guarantee what type the typevar will be specialized to.
             // (If the typevar is bounded, it might be specialized to a smaller type than the
             // bound. This is true even if the bound is a final class, since the typevar can still
             // be specialized to `Never`.)
-            (_, Type::TypeVar(_)) => false,
+            (_, Type::TypeVar(_)) => Err(TypeRelationError::todo()),
 
             // Note that the definition of `Type::AlwaysFalsy` depends on the return value of `__bool__`.
             // If `__bool__` always returns True or False, it can be treated as a subtype of `AlwaysTruthy` or `AlwaysFalsy`, respectively.
-            (left, Type::AlwaysFalsy) => left.bool(db).is_always_false(),
-            (left, Type::AlwaysTruthy) => left.bool(db).is_always_true(),
+            (left, Type::AlwaysFalsy) => {
+                if left.bool(db).is_always_false() {
+                    Ok(())
+                } else {
+                    Err(TypeRelationError::todo())
+                }
+            }
+            (left, Type::AlwaysTruthy) => {
+                if left.bool(db).is_always_true() {
+                    Ok(())
+                } else {
+                    Err(TypeRelationError::todo())
+                }
+            }
             // Currently, the only supertype of `AlwaysFalsy` and `AlwaysTruthy` is the universal set (object instance).
             (Type::AlwaysFalsy | Type::AlwaysTruthy, _) => {
-                target.is_equivalent_to(db, Type::object(db))
+                if target.is_equivalent_to(db, Type::object(db)) {
+                    Ok(())
+                } else {
+                    Err(TypeRelationError::todo())
+                }
             }
 
             // These clauses handle type variants that include function literals. A function
@@ -1404,10 +1502,10 @@ impl<'db> Type<'db> {
             // applied to the signature. Different specializations of the same function literal are
             // only subtypes of each other if they result in the same signature.
             (Type::FunctionLiteral(self_function), Type::FunctionLiteral(target_function)) => {
-                self_function.has_relation_to(db, target_function, relation)
+                self_function.try_has_relation_to(db, target_function, relation)
             }
             (Type::BoundMethod(self_method), Type::BoundMethod(target_method)) => {
-                self_method.has_relation_to(db, target_method, relation)
+                self_method.try_has_relation_to(db, target_method, relation)
             }
             (Type::MethodWrapper(self_method), Type::MethodWrapper(target_method)) => {
                 self_method.has_relation_to(db, target_method, relation)
@@ -1432,36 +1530,52 @@ impl<'db> Type<'db> {
                 | Type::FunctionLiteral(_)
                 | Type::ModuleLiteral(_)
                 | Type::EnumLiteral(_),
-            ) => false,
+            ) => Err(TypeRelationError::todo()),
 
             (Type::Callable(self_callable), Type::Callable(other_callable)) => {
                 self_callable.has_relation_to(db, other_callable, relation)
             }
 
-            (_, Type::Callable(_)) => self
-                .into_callable(db)
-                .is_some_and(|callable| callable.has_relation_to(db, target, relation)),
+            (_, Type::Callable(_)) => {
+                if let Some(callable) = self.into_callable(db) {
+                    callable.try_has_relation_to(db, target, relation)
+                } else {
+                    Err(TypeRelationError::todo())
+                }
+            }
 
             (Type::ProtocolInstance(left), Type::ProtocolInstance(right)) => {
-                left.has_relation_to(db, right, relation)
+                if left.has_relation_to(db, right, relation) {
+                    Ok(())
+                } else {
+                    Err(TypeRelationError::todo())
+                }
             }
             // A protocol instance can never be a subtype of a nominal type, with the *sole* exception of `object`.
-            (Type::ProtocolInstance(_), _) => false,
+            (Type::ProtocolInstance(_), _) => Err(TypeRelationError::todo()),
             (_, Type::ProtocolInstance(protocol)) => {
-                self.satisfies_protocol(db, protocol, relation)
+                if self.satisfies_protocol(db, protocol, relation) {
+                    Ok(())
+                } else {
+                    Err(TypeRelationError::todo())
+                }
             }
 
             // All `StringLiteral` types are a subtype of `LiteralString`.
-            (Type::StringLiteral(_), Type::LiteralString) => true,
+            (Type::StringLiteral(_), Type::LiteralString) => Ok(()),
 
             // An instance is a subtype of an enum literal, if it is an instance of the enum class
             // and the enum has only one member.
             (Type::NominalInstance(_), Type::EnumLiteral(target_enum_literal)) => {
                 if target_enum_literal.enum_class_instance(db) != self {
-                    return false;
+                    return Err(TypeRelationError::todo());
                 }
 
-                is_single_member_enum(db, target_enum_literal.enum_class(db))
+                if is_single_member_enum(db, target_enum_literal.enum_class(db)) {
+                    Ok(())
+                } else {
+                    Err(TypeRelationError::todo())
+                }
             }
 
             // Except for the special `LiteralString` case above,
@@ -1476,44 +1590,54 @@ impl<'db> Type<'db> {
                 | Type::ModuleLiteral(_)
                 | Type::EnumLiteral(_),
                 _,
-            ) => (self.literal_fallback_instance(db))
-                .is_some_and(|instance| instance.has_relation_to(db, target, relation)),
+            ) => {
+                if let Some(instance) = self.literal_fallback_instance(db) {
+                    instance.try_has_relation_to(db, target, relation)
+                } else {
+                    Err(TypeRelationError::todo())
+                }
+            }
 
             // A `FunctionLiteral` type is a single-valued type like the other literals handled above,
             // so it also, for now, just delegates to its instance fallback.
             (Type::FunctionLiteral(_), _) => KnownClass::FunctionType
                 .to_instance(db)
-                .has_relation_to(db, target, relation),
+                .try_has_relation_to(db, target, relation),
 
             // The same reasoning applies for these special callable types:
             (Type::BoundMethod(_), _) => KnownClass::MethodType
                 .to_instance(db)
-                .has_relation_to(db, target, relation),
+                .try_has_relation_to(db, target, relation),
             (Type::MethodWrapper(_), _) => KnownClass::WrapperDescriptorType
                 .to_instance(db)
-                .has_relation_to(db, target, relation),
+                .try_has_relation_to(db, target, relation),
             (Type::WrapperDescriptor(_), _) => KnownClass::WrapperDescriptorType
                 .to_instance(db)
-                .has_relation_to(db, target, relation),
+                .try_has_relation_to(db, target, relation),
 
             (Type::DataclassDecorator(_) | Type::DataclassTransformer(_), _) => {
                 // TODO: Implement subtyping using an equivalent `Callable` type.
-                false
+                Err(TypeRelationError::todo())
             }
 
             // `TypeIs` is invariant.
             (Type::TypeIs(left), Type::TypeIs(right)) => {
-                left.return_type(db)
-                    .has_relation_to(db, right.return_type(db), relation)
-                    && right
+                if let Err(e) =
+                    left.return_type(db)
+                        .try_has_relation_to(db, right.return_type(db), relation)
+                {
+                    Err(e)
+                } else {
+                    right
                         .return_type(db)
-                        .has_relation_to(db, left.return_type(db), relation)
+                        .try_has_relation_to(db, left.return_type(db), relation)
+                }
             }
 
             // `TypeIs[T]` is a subtype of `bool`.
             (Type::TypeIs(_), _) => KnownClass::Bool
                 .to_instance(db)
-                .has_relation_to(db, target, relation),
+                .try_has_relation_to(db, target, relation),
 
             // Function-like callables are subtypes of `FunctionType`
             (Type::Callable(callable), _)
@@ -1522,33 +1646,42 @@ impl<'db> Type<'db> {
                         .to_instance(db)
                         .has_relation_to(db, target, relation) =>
             {
-                true
+                Ok(())
             }
 
-            (Type::Callable(_), _) => false,
+            (Type::Callable(_), _) => Err(TypeRelationError::todo()),
 
             (Type::Tuple(self_tuple), Type::Tuple(target_tuple)) => {
                 self_tuple.has_relation_to(db, target_tuple, relation)
             }
 
-            (Type::Tuple(self_tuple), Type::NominalInstance(target_instance)) => {
-                self_tuple.to_class_type(db).is_some_and(|self_class| {
-                    self_class.has_relation_to(db, target_instance.class, relation)
+            (Type::Tuple(self_tuple), Type::NominalInstance(target_instance)) => self_tuple
+                .to_class_type(db)
+                .map(|self_class| {
+                    self_class.try_has_relation_to(db, target_instance.class, relation)
                 })
-            }
-            (Type::NominalInstance(self_instance), Type::Tuple(target_tuple)) => {
-                target_tuple.to_class_type(db).is_some_and(|target_class| {
+                .unwrap_or(Err(TypeRelationError::todo())),
+
+            (Type::NominalInstance(self_instance), Type::Tuple(target_tuple)) => target_tuple
+                .to_class_type(db)
+                .map(|target_class| {
                     self_instance
                         .class
-                        .has_relation_to(db, target_class, relation)
+                        .try_has_relation_to(db, target_class, relation)
                 })
-            }
-            (Type::Tuple(_), _) => false,
+                .unwrap_or(Err(TypeRelationError::todo())),
+            (Type::Tuple(_), _) => Err(TypeRelationError::todo()),
 
-            (Type::BoundSuper(_), Type::BoundSuper(_)) => self.is_equivalent_to(db, target),
+            (Type::BoundSuper(_), Type::BoundSuper(_)) => {
+                if self.is_equivalent_to(db, target) {
+                    Ok(())
+                } else {
+                    Err(TypeRelationError::todo())
+                }
+            }
             (Type::BoundSuper(_), _) => KnownClass::Super
                 .to_instance(db)
-                .has_relation_to(db, target, relation),
+                .try_has_relation_to(db, target, relation),
 
             // `Literal[<class 'C'>]` is a subtype of `type[B]` if `C` is a subclass of `B`,
             // since `type[B]` describes all possible runtime subclasses of the class object `B`.
@@ -1556,16 +1689,29 @@ impl<'db> Type<'db> {
                 .subclass_of()
                 .into_class()
                 .map(|subclass_of_class| {
-                    ClassType::NonGeneric(class).has_relation_to(db, subclass_of_class, relation)
+                    ClassType::NonGeneric(class).try_has_relation_to(
+                        db,
+                        subclass_of_class,
+                        relation,
+                    )
                 })
-                .unwrap_or(relation.is_assignability()),
+                .unwrap_or(if relation.is_assignability() {
+                    Ok(())
+                } else {
+                    Err(TypeRelationError::todo())
+                }),
+
             (Type::GenericAlias(alias), Type::SubclassOf(target_subclass_ty)) => target_subclass_ty
                 .subclass_of()
                 .into_class()
                 .map(|subclass_of_class| {
-                    ClassType::Generic(alias).has_relation_to(db, subclass_of_class, relation)
+                    ClassType::Generic(alias).try_has_relation_to(db, subclass_of_class, relation)
                 })
-                .unwrap_or(relation.is_assignability()),
+                .unwrap_or(if relation.is_assignability() {
+                    Ok(())
+                } else {
+                    Err(TypeRelationError::todo())
+                }),
 
             // This branch asks: given two types `type[T]` and `type[S]`, is `type[T]` a subtype of `type[S]`?
             (Type::SubclassOf(self_subclass_ty), Type::SubclassOf(target_subclass_ty)) => {
@@ -1577,25 +1723,43 @@ impl<'db> Type<'db> {
             // is an instance of its metaclass `abc.ABCMeta`.
             (Type::ClassLiteral(class), _) => class
                 .metaclass_instance_type(db)
-                .has_relation_to(db, target, relation),
+                .try_has_relation_to(db, target, relation),
             (Type::GenericAlias(alias), _) => ClassType::from(alias)
                 .metaclass_instance_type(db)
-                .has_relation_to(db, target, relation),
+                .try_has_relation_to(db, target, relation),
 
             // `type[Any]` is a subtype of `type[object]`, and is assignable to any `type[...]`
             (Type::SubclassOf(subclass_of_ty), other) if subclass_of_ty.is_dynamic() => {
-                KnownClass::Type
+                match KnownClass::Type
                     .to_instance(db)
-                    .has_relation_to(db, other, relation)
-                    || (relation.is_assignability()
-                        && other.has_relation_to(db, KnownClass::Type.to_instance(db), relation))
+                    .try_has_relation_to(db, other, relation)
+                {
+                    Ok(()) => Ok(()),
+                    Err(mut e1) => {
+                        if relation.is_assignability() {
+                            match other.try_has_relation_to(
+                                db,
+                                KnownClass::Type.to_instance(db),
+                                relation,
+                            ) {
+                                Ok(()) => Ok(()),
+                                Err(e2) => {
+                                    e1.add(Err(e2));
+                                    Err(e1)
+                                }
+                            }
+                        } else {
+                            Err(e1)
+                        }
+                    }
+                }
             }
 
             // Any `type[...]` type is assignable to `type[Any]`
             (other, Type::SubclassOf(subclass_of_ty))
                 if subclass_of_ty.is_dynamic() && relation.is_assignability() =>
             {
-                other.has_relation_to(db, KnownClass::Type.to_instance(db), relation)
+                other.try_has_relation_to(db, KnownClass::Type.to_instance(db), relation)
             }
 
             // `type[str]` (== `SubclassOf("str")` in ty) describes all possible runtime subclasses
@@ -1610,35 +1774,35 @@ impl<'db> Type<'db> {
                 .into_class()
                 .map(|class| class.metaclass_instance_type(db))
                 .unwrap_or_else(|| KnownClass::Type.to_instance(db))
-                .has_relation_to(db, target, relation),
+                .try_has_relation_to(db, target, relation),
 
             // For example: `Type::SpecialForm(SpecialFormType::Type)` is a subtype of `Type::NominalInstance(_SpecialForm)`,
             // because `Type::SpecialForm(SpecialFormType::Type)` is a set with exactly one runtime value in it
             // (the symbol `typing.Type`), and that symbol is known to be an instance of `typing._SpecialForm` at runtime.
             (Type::SpecialForm(left), right) => left
                 .instance_fallback(db)
-                .has_relation_to(db, right, relation),
+                .try_has_relation_to(db, right, relation),
 
             (Type::KnownInstance(left), right) => left
                 .instance_fallback(db)
-                .has_relation_to(db, right, relation),
+                .try_has_relation_to(db, right, relation),
 
             // `bool` is a subtype of `int`, because `bool` subclasses `int`,
             // which means that all instances of `bool` are also instances of `int`
             (Type::NominalInstance(self_instance), Type::NominalInstance(target_instance)) => {
-                self_instance.has_relation_to(db, target_instance, relation)
+                self_instance.try_has_relation_to(db, target_instance, relation)
             }
 
             (Type::PropertyInstance(_), _) => KnownClass::Property
                 .to_instance(db)
-                .has_relation_to(db, target, relation),
+                .try_has_relation_to(db, target, relation),
             (_, Type::PropertyInstance(_)) => {
-                self.has_relation_to(db, KnownClass::Property.to_instance(db), relation)
+                self.try_has_relation_to(db, KnownClass::Property.to_instance(db), relation)
             }
 
             // Other than the special cases enumerated above, `Instance` types and typevars are
             // never subtypes of any other variants
-            (Type::NominalInstance(_) | Type::TypeVar(_), _) => false,
+            (Type::NominalInstance(_) | Type::TypeVar(_), _) => Err(TypeRelationError::todo()),
         }
     }
 
@@ -2031,7 +2195,7 @@ impl<'db> Type<'db> {
                 match subclass_of_ty.subclass_of() {
                     SubclassOfInner::Dynamic(_) => false,
                     SubclassOfInner::Class(class_a) => {
-                        !ClassType::from(alias_b).is_subclass_of(db, class_a)
+                        ClassType::from(alias_b).try_is_subclass_of(db, class_a).is_err()
                     }
                 }
             }
@@ -7377,6 +7541,55 @@ impl<'db> ConstructorCallError<'db> {
     }
 }
 
+#[derive(Debug, Clone, PartialEq, Eq)]
+pub(crate) struct TypeRelationError(pub(crate) Vec<TypeRelationErrorKind>);
+
+impl TypeRelationError {
+    pub(crate) fn single(kind: TypeRelationErrorKind) -> Self {
+        Self(vec![kind])
+    }
+
+    pub(crate) fn todo() -> Self {
+        Self(vec![TypeRelationErrorKind::Todo])
+    }
+
+    pub(crate) fn from_results(
+        results: impl IntoIterator<Item = Result<(), TypeRelationError>>,
+    ) -> Result<(), TypeRelationError> {
+        let mut errors = Vec::new();
+        for result in results {
+            if let Err(err) = result {
+                errors.extend(err.0);
+            }
+        }
+        if errors.is_empty() {
+            Ok(())
+        } else {
+            Err(TypeRelationError(errors))
+        }
+    }
+
+    pub(crate) fn add(&mut self, other: Result<(), TypeRelationError>) {
+        if let Err(e) = other {
+            self.0.extend(e.0);
+        }
+    }
+}
+
+impl Iterator for TypeRelationError {
+    type Item = TypeRelationErrorKind;
+
+    fn next(&mut self) -> Option<Self::Item> {
+        self.0.pop()
+    }
+}
+
+#[derive(Debug, Copy, Clone, PartialEq, Eq)]
+pub(crate) enum TypeRelationErrorKind {
+    Todo,
+    GradualTypeInSubTyping,
+}
+
 #[derive(Debug, Copy, Clone, PartialEq, Eq)]
 pub(crate) enum TypeRelation {
     Subtyping,
@@ -7517,16 +7730,28 @@ impl<'db> BoundMethodType<'db> {
         )
     }
 
-    fn has_relation_to(self, db: &'db dyn Db, other: Self, relation: TypeRelation) -> bool {
+    fn try_has_relation_to(
+        self,
+        db: &'db dyn Db,
+        other: Self,
+        relation: TypeRelation,
+    ) -> Result<(), TypeRelationError> {
         // A bound method is a typically a subtype of itself. However, we must explicitly verify
         // the subtyping of the underlying function signatures (since they might be specialized
         // differently), and of the bound self parameter (taking care that parameters, including a
         // bound self parameter, are contravariant.)
-        self.function(db)
-            .has_relation_to(db, other.function(db), relation)
-            && other
-                .self_instance(db)
-                .has_relation_to(db, self.self_instance(db), relation)
+
+        match self
+            .function(db)
+            .try_has_relation_to(db, other.function(db), relation)
+        {
+            Err(e) => Err(e),
+            Ok(()) => {
+                other
+                    .self_instance(db)
+                    .try_has_relation_to(db, self.self_instance(db), relation)
+            }
+        }
     }
 
     fn is_equivalent_to(self, db: &'db dyn Db, other: Self) -> bool {
@@ -7653,9 +7878,14 @@ impl<'db> CallableType<'db> {
     /// Check whether this callable type has the given relation to another callable type.
     ///
     /// See [`Type::is_subtype_of`] and [`Type::is_assignable_to`] for more details.
-    fn has_relation_to(self, db: &'db dyn Db, other: Self, relation: TypeRelation) -> bool {
+    fn has_relation_to(
+        self,
+        db: &'db dyn Db,
+        other: Self,
+        relation: TypeRelation,
+    ) -> Result<(), TypeRelationError> {
         if other.is_function_like(db) && !self.is_function_like(db) {
-            return false;
+            return Err(TypeRelationError::todo());
         }
         self.signatures(db)
             .has_relation_to(db, other.signatures(db), relation)
@@ -7722,22 +7952,31 @@ pub(super) fn walk_method_wrapper_type<'db, V: visitor::TypeVisitor<'db> + ?Size
 }
 
 impl<'db> MethodWrapperKind<'db> {
-    fn has_relation_to(self, db: &'db dyn Db, other: Self, relation: TypeRelation) -> bool {
+    fn has_relation_to(
+        self,
+        db: &'db dyn Db,
+        other: Self,
+        relation: TypeRelation,
+    ) -> Result<(), TypeRelationError> {
         match (self, other) {
             (
                 MethodWrapperKind::FunctionTypeDunderGet(self_function),
                 MethodWrapperKind::FunctionTypeDunderGet(other_function),
-            ) => self_function.has_relation_to(db, other_function, relation),
+            ) => self_function.try_has_relation_to(db, other_function, relation),
 
             (
                 MethodWrapperKind::FunctionTypeDunderCall(self_function),
                 MethodWrapperKind::FunctionTypeDunderCall(other_function),
-            ) => self_function.has_relation_to(db, other_function, relation),
+            ) => self_function.try_has_relation_to(db, other_function, relation),
 
             (MethodWrapperKind::PropertyDunderGet(_), MethodWrapperKind::PropertyDunderGet(_))
             | (MethodWrapperKind::PropertyDunderSet(_), MethodWrapperKind::PropertyDunderSet(_))
             | (MethodWrapperKind::StrStartswith(_), MethodWrapperKind::StrStartswith(_)) => {
-                self == other
+                if self == other {
+                    Ok(())
+                } else {
+                    Err(TypeRelationError::todo())
+                }
             }
 
             (
@@ -7751,7 +7990,7 @@ impl<'db> MethodWrapperKind<'db> {
                 | MethodWrapperKind::PropertyDunderGet(_)
                 | MethodWrapperKind::PropertyDunderSet(_)
                 | MethodWrapperKind::StrStartswith(_),
-            ) => false,
+            ) => Err(TypeRelationError::todo()),
         }
     }
 
@@ -8743,7 +8982,7 @@ impl<'db> BoundSuperType<'db> {
                 let Some(owner_class) = owner.into_class() else {
                     return Some(owner);
                 };
-                if owner_class.is_subclass_of(db, pivot_class) {
+                if owner_class.try_is_subclass_of(db, pivot_class).is_ok() {
                     Some(owner)
                 } else {
                     None
diff --git a/crates/ty_python_semantic/src/types/class.rs b/crates/ty_python_semantic/src/types/class.rs
index b7157dbc0..52eeb1c7f 100644
--- a/crates/ty_python_semantic/src/types/class.rs
+++ b/crates/ty_python_semantic/src/types/class.rs
@@ -23,8 +23,8 @@ use crate::types::tuple::TupleType;
 use crate::types::{
     BareTypeAliasType, Binding, BoundSuperError, BoundSuperType, CallableType, DataclassParams,
     DeprecatedInstance, DynamicType, KnownInstanceType, TypeAliasType, TypeMapping, TypeRelation,
-    TypeTransformer, TypeVarBoundOrConstraints, TypeVarInstance, TypeVarKind, declaration_type,
-    infer_definition_types,
+    TypeRelationError, TypeTransformer, TypeVarBoundOrConstraints, TypeVarInstance, TypeVarKind,
+    declaration_type, infer_definition_types,
 };
 use crate::{
     Db, FxOrderSet, KnownModule, Program,
@@ -409,49 +409,89 @@ impl<'db> ClassType<'db> {
 
     /// Return `true` if `other` is present in this class's MRO.
     pub(super) fn is_subclass_of(self, db: &'db dyn Db, other: ClassType<'db>) -> bool {
-        self.has_relation_to(db, other, TypeRelation::Subtyping)
+        self.try_is_subclass_of(db, other).is_ok()
     }
 
-    pub(super) fn has_relation_to(
+    pub(super) fn try_is_subclass_of(
+        self,
+        db: &'db dyn Db,
+        other: ClassType<'db>,
+    ) -> Result<(), TypeRelationError> {
+        self.try_has_relation_to(db, other, TypeRelation::Subtyping)
+    }
+
+    pub(super) fn try_has_relation_to(
         self,
         db: &'db dyn Db,
         other: Self,
         relation: TypeRelation,
-    ) -> bool {
+    ) -> Result<(), TypeRelationError> {
         // TODO: remove this branch once we have proper support for TypedDicts.
         if self.is_known(db, KnownClass::Dict)
             && other
                 .iter_mro(db)
                 .any(|b| matches!(b, ClassBase::Dynamic(DynamicType::TodoTypedDict)))
         {
-            return true;
+            return Ok(());
         }
 
-        self.iter_mro(db).any(|base| {
-            match base {
-                ClassBase::Dynamic(_) => match relation {
-                    TypeRelation::Subtyping => other.is_object(db),
-                    TypeRelation::Assignability => !other.is_final(db),
-                },
+        let results = self
+            .iter_mro(db)
+            .map(|base| {
+                match base {
+                    ClassBase::Dynamic(_) => match relation {
+                        TypeRelation::Subtyping => {
+                            if other.is_object(db) {
+                                Ok(())
+                            } else {
+                                Err(TypeRelationError::todo())
+                            }
+                        }
+                        TypeRelation::Assignability => {
+                            if other.is_final(db) {
+                                Err(TypeRelationError::todo())
+                            } else {
+                                Ok(())
+                            }
+                        }
+                    },
 
-                // Protocol and Generic are not represented by a ClassType.
-                ClassBase::Protocol | ClassBase::Generic => false,
+                    // Protocol and Generic are not represented by a ClassType.
+                    ClassBase::Protocol | ClassBase::Generic => Err(TypeRelationError::todo()),
 
-                ClassBase::Class(base) => match (base, other) {
-                    (ClassType::NonGeneric(base), ClassType::NonGeneric(other)) => base == other,
-                    (ClassType::Generic(base), ClassType::Generic(other)) => {
-                        base.origin(db) == other.origin(db)
-                            && base.specialization(db).has_relation_to(
-                                db,
-                                other.specialization(db),
-                                relation,
-                            )
-                    }
-                    (ClassType::Generic(_), ClassType::NonGeneric(_))
-                    | (ClassType::NonGeneric(_), ClassType::Generic(_)) => false,
-                },
-            }
-        })
+                    ClassBase::Class(base) => match (base, other) {
+                        (ClassType::NonGeneric(base), ClassType::NonGeneric(other)) => {
+                            if base == other {
+                                Ok(())
+                            } else {
+                                Err(TypeRelationError::todo())
+                            }
+                        }
+                        (ClassType::Generic(base), ClassType::Generic(other)) => {
+                            if base.origin(db) == other.origin(db) {
+                                base.specialization(db).has_relation_to(
+                                    db,
+                                    other.specialization(db),
+                                    relation,
+                                )
+                            } else {
+                                Err(TypeRelationError::todo())
+                            }
+                        }
+                        (ClassType::Generic(_), ClassType::NonGeneric(_))
+                        | (ClassType::NonGeneric(_), ClassType::Generic(_)) => {
+                            Err(TypeRelationError::todo())
+                        }
+                    },
+                }
+            })
+            .collect::<Vec<_>>();
+
+        if results.iter().any(Result::is_ok) {
+            Ok(())
+        } else {
+            TypeRelationError::from_results(results)
+        }
     }
 
     pub(super) fn is_equivalent_to(self, db: &'db dyn Db, other: ClassType<'db>) -> bool {
@@ -502,10 +542,10 @@ impl<'db> ClassType<'db> {
 
         // Optimisation: if either class is `@final`, we only need to do one `is_subclass_of` call.
         if self.is_final(db) {
-            return self.is_subclass_of(db, other);
+            return self.try_is_subclass_of(db, other).is_ok();
         }
         if other.is_final(db) {
-            return other.is_subclass_of(db, self);
+            return other.try_is_subclass_of(db, self).is_ok();
         }
 
         // Two solid bases can only coexist in an MRO if one is a subclass of the other.
@@ -1372,7 +1412,10 @@ impl<'db> ClassLiteral<'db> {
             let Some(metaclass) = metaclass.to_class_type(db) else {
                 continue;
             };
-            if metaclass.is_subclass_of(db, candidate.metaclass) {
+            if metaclass
+                .try_is_subclass_of(db, candidate.metaclass)
+                .is_ok()
+            {
                 let (base_class_literal, _) = base_class.class_literal(db);
                 candidate = MetaclassCandidate {
                     metaclass,
@@ -1380,7 +1423,11 @@ impl<'db> ClassLiteral<'db> {
                 };
                 continue;
             }
-            if candidate.metaclass.is_subclass_of(db, metaclass) {
+            if candidate
+                .metaclass
+                .try_is_subclass_of(db, metaclass)
+                .is_ok()
+            {
                 continue;
             }
             let (base_class_literal, _) = base_class.class_literal(db);
diff --git a/crates/ty_python_semantic/src/types/function.rs b/crates/ty_python_semantic/src/types/function.rs
index d1c7140fd..1f6ae58bc 100644
--- a/crates/ty_python_semantic/src/types/function.rs
+++ b/crates/ty_python_semantic/src/types/function.rs
@@ -77,8 +77,8 @@ use crate::types::signatures::{CallableSignature, Signature};
 use crate::types::visitor::any_over_type;
 use crate::types::{
     BoundMethodType, CallableType, ClassLiteral, ClassType, DeprecatedInstance, DynamicType,
-    KnownClass, Truthiness, Type, TypeMapping, TypeRelation, TypeTransformer, TypeVarInstance,
-    UnionBuilder, walk_type_mapping,
+    KnownClass, Truthiness, Type, TypeMapping, TypeRelation, TypeRelationError, TypeTransformer,
+    TypeVarInstance, UnionBuilder, walk_type_mapping,
 };
 use crate::{Db, FxOrderSet, ModuleName, resolve_module};
 
@@ -805,41 +805,51 @@ impl<'db> FunctionType<'db> {
         Type::BoundMethod(BoundMethodType::new(db, self, self_instance))
     }
 
-    pub(crate) fn has_relation_to(
+    pub(crate) fn try_has_relation_to(
         self,
         db: &'db dyn Db,
         other: Self,
         relation: TypeRelation,
-    ) -> bool {
+    ) -> Result<(), TypeRelationError> {
         match relation {
-            TypeRelation::Subtyping => self.is_subtype_of(db, other),
-            TypeRelation::Assignability => self.is_assignable_to(db, other),
+            TypeRelation::Subtyping => self.try_is_subtype_of(db, other),
+            TypeRelation::Assignability => self.try_is_assignable_to(db, other),
         }
     }
 
-    pub(crate) fn is_subtype_of(self, db: &'db dyn Db, other: Self) -> bool {
+    pub(crate) fn try_is_subtype_of(
+        self,
+        db: &'db dyn Db,
+        other: Self,
+    ) -> Result<(), TypeRelationError> {
         // A function type is the subtype of itself, and not of any other function type. However,
         // our representation of a function type includes any specialization that should be applied
         // to the signature. Different specializations of the same function type are only subtypes
         // of each other if they result in subtype signatures.
         if self.normalized(db) == other.normalized(db) {
-            return true;
+            return Ok(());
         }
         if self.literal(db) != other.literal(db) {
-            return false;
+            return Err(TypeRelationError::todo());
         }
         let self_signature = self.signature(db);
         let other_signature = other.signature(db);
         self_signature.is_subtype_of(db, other_signature)
     }
 
-    pub(crate) fn is_assignable_to(self, db: &'db dyn Db, other: Self) -> bool {
+    pub(crate) fn try_is_assignable_to(
+        self,
+        db: &'db dyn Db,
+        other: Self,
+    ) -> Result<(), TypeRelationError> {
         // A function type is assignable to itself, and not to any other function type. However,
         // our representation of a function type includes any specialization that should be applied
         // to the signature. Different specializations of the same function type are only
         // assignable to each other if they result in assignable signatures.
-        self.literal(db) == other.literal(db)
-            && self.signature(db).is_assignable_to(db, other.signature(db))
+        if self.literal(db) != other.literal(db) {
+            return Err(TypeRelationError::todo());
+        }
+        self.signature(db).is_assignable_to(db, other.signature(db))
     }
 
     pub(crate) fn is_equivalent_to(self, db: &'db dyn Db, other: Self) -> bool {
@@ -897,7 +907,8 @@ fn is_instance_truthiness<'db>(
         if let Type::NominalInstance(instance) = ty {
             if instance
                 .class
-                .is_subclass_of(db, ClassType::NonGeneric(class))
+                .try_is_subclass_of(db, ClassType::NonGeneric(class))
+                .is_ok()
             {
                 return true;
             }
diff --git a/crates/ty_python_semantic/src/types/generics.rs b/crates/ty_python_semantic/src/types/generics.rs
index f19a1a477..7cd28ca57 100644
--- a/crates/ty_python_semantic/src/types/generics.rs
+++ b/crates/ty_python_semantic/src/types/generics.rs
@@ -13,8 +13,9 @@ use crate::types::instance::{NominalInstanceType, Protocol, ProtocolInstanceType
 use crate::types::signatures::{Parameter, Parameters, Signature};
 use crate::types::tuple::{TupleSpec, TupleType};
 use crate::types::{
-    KnownInstanceType, Type, TypeMapping, TypeRelation, TypeTransformer, TypeVarBoundOrConstraints,
-    TypeVarInstance, TypeVarVariance, UnionType, binding_type, declaration_type,
+    KnownInstanceType, Type, TypeMapping, TypeRelation, TypeRelationError, TypeTransformer,
+    TypeVarBoundOrConstraints, TypeVarInstance, TypeVarVariance, UnionType, binding_type,
+    declaration_type,
 };
 use crate::{Db, FxOrderSet};
 
@@ -515,10 +516,10 @@ impl<'db> Specialization<'db> {
         db: &'db dyn Db,
         other: Self,
         relation: TypeRelation,
-    ) -> bool {
+    ) -> Result<(), TypeRelationError> {
         let generic_context = self.generic_context(db);
         if generic_context != other.generic_context(db) {
-            return false;
+            return Err(TypeRelationError::todo());
         }
 
         if let (Some(self_tuple), Some(other_tuple)) = (self.tuple_inner(db), other.tuple_inner(db))
@@ -533,7 +534,7 @@ impl<'db> Specialization<'db> {
             if self_type.is_dynamic() || other_type.is_dynamic() {
                 match relation {
                     TypeRelation::Assignability => continue,
-                    TypeRelation::Subtyping => return false,
+                    TypeRelation::Subtyping => return Err(TypeRelationError::todo()),
                 }
             }
 
@@ -545,24 +546,33 @@ impl<'db> Specialization<'db> {
             //   - bivariant: skip, can't make subtyping/assignability false
             let compatible = match typevar.variance(db) {
                 TypeVarVariance::Invariant => match relation {
-                    TypeRelation::Subtyping => self_type.is_equivalent_to(db, *other_type),
+                    TypeRelation::Subtyping => {
+                        if self_type.is_equivalent_to(db, *other_type) {
+                            Ok(())
+                        } else {
+                            Err(TypeRelationError::todo())
+                        }
+                    }
                     TypeRelation::Assignability => {
-                        self_type.is_assignable_to(db, *other_type)
-                            && other_type.is_assignable_to(db, *self_type)
+                        match self_type.try_is_assignable_to(db, *other_type) {
+                            Ok(()) => other_type.try_is_assignable_to(db, *self_type),
+                            Err(e) => Err(e),
+                        }
                     }
                 },
-                TypeVarVariance::Covariant => self_type.has_relation_to(db, *other_type, relation),
+                TypeVarVariance::Covariant => {
+                    self_type.try_has_relation_to(db, *other_type, relation)
+                }
                 TypeVarVariance::Contravariant => {
-                    other_type.has_relation_to(db, *self_type, relation)
+                    other_type.try_has_relation_to(db, *self_type, relation)
                 }
-                TypeVarVariance::Bivariant => true,
+                TypeVarVariance::Bivariant => Ok(()),
             };
-            if !compatible {
-                return false;
-            }
+
+            compatible?;
         }
 
-        true
+        Ok(())
     }
 
     pub(crate) fn is_equivalent_to(self, db: &'db dyn Db, other: Specialization<'db>) -> bool {
diff --git a/crates/ty_python_semantic/src/types/infer.rs b/crates/ty_python_semantic/src/types/infer.rs
index 0c45e0780..c9abecb5b 100644
--- a/crates/ty_python_semantic/src/types/infer.rs
+++ b/crates/ty_python_semantic/src/types/infer.rs
@@ -3654,6 +3654,7 @@ impl<'db, 'ast> TypeInferenceBuilder<'db, 'ast> {
                     attribute,
                 );
             }
+
             assignable
         };
 
diff --git a/crates/ty_python_semantic/src/types/instance.rs b/crates/ty_python_semantic/src/types/instance.rs
index 3959b041e..79d6d1de4 100644
--- a/crates/ty_python_semantic/src/types/instance.rs
+++ b/crates/ty_python_semantic/src/types/instance.rs
@@ -9,7 +9,9 @@ use crate::types::cyclic::PairVisitor;
 use crate::types::enums::is_single_member_enum;
 use crate::types::protocol_class::walk_protocol_interface;
 use crate::types::tuple::TupleType;
-use crate::types::{DynamicType, TypeMapping, TypeRelation, TypeTransformer, TypeVarInstance};
+use crate::types::{
+    DynamicType, TypeMapping, TypeRelation, TypeRelationError, TypeTransformer, TypeVarInstance,
+};
 use crate::{Db, FxOrderSet};
 
 pub(super) use synthesized_protocol::SynthesizedProtocolType;
@@ -107,13 +109,13 @@ impl<'db> NominalInstanceType<'db> {
         Self::from_class(self.class.materialize(db, variance))
     }
 
-    pub(super) fn has_relation_to(
+    pub(super) fn try_has_relation_to(
         self,
         db: &'db dyn Db,
         other: Self,
         relation: TypeRelation,
-    ) -> bool {
-        self.class.has_relation_to(db, other.class, relation)
+    ) -> Result<(), TypeRelationError> {
+        self.class.try_has_relation_to(db, other.class, relation)
     }
 
     pub(super) fn is_equivalent_to(self, db: &'db dyn Db, other: Self) -> bool {
diff --git a/crates/ty_python_semantic/src/types/signatures.rs b/crates/ty_python_semantic/src/types/signatures.rs
index 70c923bdb..f921d71e6 100644
--- a/crates/ty_python_semantic/src/types/signatures.rs
+++ b/crates/ty_python_semantic/src/types/signatures.rs
@@ -18,7 +18,9 @@ use smallvec::{SmallVec, smallvec_inline};
 use super::{DynamicType, Type, TypeTransformer, TypeVarVariance, definition_expression_type};
 use crate::semantic_index::definition::Definition;
 use crate::types::generics::{GenericContext, walk_generic_context};
-use crate::types::{TypeMapping, TypeRelation, TypeVarInstance, todo_type};
+use crate::types::{
+    TypeMapping, TypeRelation, TypeRelationError, TypeRelationErrorKind, TypeVarInstance, todo_type,
+};
 use crate::{Db, FxOrderSet};
 use ruff_python_ast::{self as ast, name::Name};
 
@@ -106,7 +108,7 @@ impl<'db> CallableSignature<'db> {
         db: &'db dyn Db,
         other: &Self,
         relation: TypeRelation,
-    ) -> bool {
+    ) -> Result<(), TypeRelationError> {
         match relation {
             TypeRelation::Subtyping => self.is_subtype_of(db, other),
             TypeRelation::Assignability => self.is_assignable_to(db, other),
@@ -116,7 +118,11 @@ impl<'db> CallableSignature<'db> {
     /// Check whether this callable type is a subtype of another callable type.
     ///
     /// See [`Type::is_subtype_of`] for more details.
-    pub(crate) fn is_subtype_of(&self, db: &'db dyn Db, other: &Self) -> bool {
+    pub(crate) fn is_subtype_of(
+        &self,
+        db: &'db dyn Db,
+        other: &Self,
+    ) -> Result<(), TypeRelationError> {
         Self::has_relation_to_impl(
             db,
             &self.overloads,
@@ -128,7 +134,11 @@ impl<'db> CallableSignature<'db> {
     /// Check whether this callable type is assignable to another callable type.
     ///
     /// See [`Type::is_assignable_to`] for more details.
-    pub(crate) fn is_assignable_to(&self, db: &'db dyn Db, other: &Self) -> bool {
+    pub(crate) fn is_assignable_to(
+        &self,
+        db: &'db dyn Db,
+        other: &Self,
+    ) -> Result<(), TypeRelationError> {
         Self::has_relation_to_impl(
             db,
             &self.overloads,
@@ -144,7 +154,7 @@ impl<'db> CallableSignature<'db> {
         self_signatures: &[Signature<'db>],
         other_signatures: &[Signature<'db>],
         relation: TypeRelation,
-    ) -> bool {
+    ) -> Result<(), TypeRelationError> {
         match (self_signatures, other_signatures) {
             ([self_signature], [other_signature]) => {
                 // Base case: both callable types contain a single signature.
@@ -152,34 +162,67 @@ impl<'db> CallableSignature<'db> {
             }
 
             // `self` is possibly overloaded while `other` is definitely not overloaded.
-            (_, [_]) => self_signatures.iter().any(|self_signature| {
-                Self::has_relation_to_impl(
-                    db,
-                    std::slice::from_ref(self_signature),
-                    other_signatures,
-                    relation,
-                )
-            }),
+            (_, [_]) => {
+                let results = self_signatures
+                    .iter()
+                    .map(|self_signature| {
+                        Self::has_relation_to_impl(
+                            db,
+                            std::slice::from_ref(self_signature),
+                            other_signatures,
+                            relation,
+                        )
+                    })
+                    .collect::<Vec<_>>();
+
+                if results.iter().any(Result::is_ok) {
+                    Ok(())
+                } else {
+                    TypeRelationError::from_results(results)
+                }
+            }
 
             // `self` is definitely not overloaded while `other` is possibly overloaded.
-            ([_], _) => other_signatures.iter().all(|other_signature| {
-                Self::has_relation_to_impl(
-                    db,
-                    self_signatures,
-                    std::slice::from_ref(other_signature),
-                    relation,
-                )
-            }),
+            ([_], _) => {
+                let results = other_signatures
+                    .iter()
+                    .map(|other_signature| {
+                        Self::has_relation_to_impl(
+                            db,
+                            self_signatures,
+                            std::slice::from_ref(other_signature),
+                            relation,
+                        )
+                    })
+                    .collect::<Vec<_>>();
+
+                if results.iter().all(Result::is_ok) {
+                    Ok(())
+                } else {
+                    TypeRelationError::from_results(results)
+                }
+            }
 
             // `self` is definitely overloaded while `other` is possibly overloaded.
-            (_, _) => other_signatures.iter().all(|other_signature| {
-                Self::has_relation_to_impl(
-                    db,
-                    self_signatures,
-                    std::slice::from_ref(other_signature),
-                    relation,
-                )
-            }),
+            (_, _) => {
+                let results = other_signatures
+                    .iter()
+                    .map(|other_signature| {
+                        Self::has_relation_to_impl(
+                            db,
+                            self_signatures,
+                            std::slice::from_ref(other_signature),
+                            relation,
+                        )
+                    })
+                    .collect::<Vec<_>>();
+
+                if results.iter().all(Result::is_ok) {
+                    Ok(())
+                } else {
+                    TypeRelationError::from_results(results)
+                }
+            }
         }
     }
 
@@ -197,7 +240,7 @@ impl<'db> CallableSignature<'db> {
                 if self == other {
                     return true;
                 }
-                self.is_subtype_of(db, other) && other.is_subtype_of(db, self)
+                self.is_subtype_of(db, other).is_ok() && other.is_subtype_of(db, self).is_ok()
             }
         }
     }
@@ -532,7 +575,7 @@ impl<'db> Signature<'db> {
         db: &'db dyn Db,
         other: &Signature<'db>,
         relation: TypeRelation,
-    ) -> bool {
+    ) -> Result<(), TypeRelationError> {
         /// A helper struct to zip two slices of parameters together that provides control over the
         /// two iterators individually. It also keeps track of the current parameter in each
         /// iterator.
@@ -595,7 +638,7 @@ impl<'db> Signature<'db> {
         }
 
         let check_types = |type1: Option<Type<'db>>, type2: Option<Type<'db>>| {
-            type1.unwrap_or(Type::unknown()).has_relation_to(
+            type1.unwrap_or(Type::unknown()).try_has_relation_to(
                 db,
                 type2.unwrap_or(Type::unknown()),
                 relation,
@@ -603,9 +646,7 @@ impl<'db> Signature<'db> {
         };
 
         // Return types are covariant.
-        if !check_types(self.return_ty, other.return_ty) {
-            return false;
-        }
+        check_types(self.return_ty, other.return_ty)?;
 
         // A gradual parameter list is a supertype of the "bottom" parameter list (*args: object,
         // **kwargs: object).
@@ -619,13 +660,18 @@ impl<'db> Signature<'db> {
                 .keyword_variadic()
                 .is_some_and(|(_, param)| param.annotated_type().is_some_and(|ty| ty.is_object(db)))
         {
-            return true;
+            return Ok(());
         }
 
         // If either of the parameter lists is gradual (`...`), then it is assignable to and from
         // any other parameter list, but not a subtype or supertype of any other parameter list.
         if self.parameters.is_gradual() || other.parameters.is_gradual() {
-            return relation.is_assignability();
+            if relation.is_assignability() {
+                return Ok(());
+            }
+            return Err(TypeRelationError::single(
+                TypeRelationErrorKind::GradualTypeInSubTyping,
+            ));
         }
 
         let mut parameters = ParametersZip {
@@ -643,7 +689,7 @@ impl<'db> Signature<'db> {
             let Some(next_parameter) = parameters.next() else {
                 // All parameters have been checked or both the parameter lists were empty. In
                 // either case, `self` is a subtype of `other`.
-                return true;
+                return Ok(());
             };
 
             match next_parameter {
@@ -663,7 +709,7 @@ impl<'db> Signature<'db> {
                         // `other`, then the non-variadic parameters in `self` must have a default
                         // value.
                         if default_type.is_none() {
-                            return false;
+                            return Err(TypeRelationError::todo());
                         }
                     }
                     ParameterKind::Variadic { .. } | ParameterKind::KeywordVariadic { .. } => {
@@ -675,7 +721,7 @@ impl<'db> Signature<'db> {
                 EitherOrBoth::Right(_) => {
                     // If there are more parameters in `other` than in `self`, then `self` is not a
                     // subtype of `other`.
-                    return false;
+                    return Err(TypeRelationError::todo());
                 }
 
                 EitherOrBoth::Both(self_parameter, other_parameter) => {
@@ -695,14 +741,12 @@ impl<'db> Signature<'db> {
                             },
                         ) => {
                             if self_default.is_none() && other_default.is_some() {
-                                return false;
+                                return Err(TypeRelationError::todo());
                             }
-                            if !check_types(
+                            check_types(
                                 other_parameter.annotated_type(),
                                 self_parameter.annotated_type(),
-                            ) {
-                                return false;
-                            }
+                            )?;
                         }
 
                         (
@@ -716,18 +760,16 @@ impl<'db> Signature<'db> {
                             },
                         ) => {
                             if self_name != other_name {
-                                return false;
+                                return Err(TypeRelationError::todo());
                             }
                             // The following checks are the same as positional-only parameters.
                             if self_default.is_none() && other_default.is_some() {
-                                return false;
+                                return Err(TypeRelationError::todo());
                             }
-                            if !check_types(
+                            check_types(
                                 other_parameter.annotated_type(),
                                 self_parameter.annotated_type(),
-                            ) {
-                                return false;
-                            }
+                            )?;
                         }
 
                         (
@@ -735,12 +777,10 @@ impl<'db> Signature<'db> {
                             ParameterKind::PositionalOnly { .. }
                             | ParameterKind::PositionalOrKeyword { .. },
                         ) => {
-                            if !check_types(
+                            check_types(
                                 other_parameter.annotated_type(),
                                 self_parameter.annotated_type(),
-                            ) {
-                                return false;
-                            }
+                            )?;
 
                             if matches!(
                                 other_parameter.kind(),
@@ -775,23 +815,19 @@ impl<'db> Signature<'db> {
                                         break;
                                     }
                                 }
-                                if !check_types(
+                                check_types(
                                     other_parameter.annotated_type(),
                                     self_parameter.annotated_type(),
-                                ) {
-                                    return false;
-                                }
+                                )?;
                                 parameters.next_other();
                             }
                         }
 
                         (ParameterKind::Variadic { .. }, ParameterKind::Variadic { .. }) => {
-                            if !check_types(
+                            check_types(
                                 other_parameter.annotated_type(),
                                 self_parameter.annotated_type(),
-                            ) {
-                                return false;
-                            }
+                            )?;
                         }
 
                         (
@@ -805,7 +841,7 @@ impl<'db> Signature<'db> {
                             break;
                         }
 
-                        _ => return false,
+                        _ => return Err(TypeRelationError::todo()),
                     }
                 }
             }
@@ -839,7 +875,7 @@ impl<'db> Signature<'db> {
                     // previous loop. They cannot be matched against any parameter in `other` which
                     // only contains keyword-only and keyword-variadic parameters so the subtype
                     // relation is invalid.
-                    return false;
+                    return Err(TypeRelationError::todo());
                 }
                 ParameterKind::Variadic { .. } => {}
             }
@@ -866,43 +902,34 @@ impl<'db> Signature<'db> {
                                 ..
                             } => {
                                 if self_default.is_none() && other_default.is_some() {
-                                    return false;
+                                    return Err(TypeRelationError::todo());
                                 }
-                                if !check_types(
+                                check_types(
                                     other_parameter.annotated_type(),
                                     self_parameter.annotated_type(),
-                                ) {
-                                    return false;
-                                }
+                                )?;
                             }
                             _ => unreachable!(
                                 "`self_keywords` should only contain keyword-only or standard parameters"
                             ),
                         }
                     } else if let Some(self_keyword_variadic_type) = self_keyword_variadic {
-                        if !check_types(
-                            other_parameter.annotated_type(),
-                            self_keyword_variadic_type,
-                        ) {
-                            return false;
-                        }
+                        check_types(other_parameter.annotated_type(), self_keyword_variadic_type)?;
                     } else {
-                        return false;
+                        return Err(TypeRelationError::todo());
                     }
                 }
                 ParameterKind::KeywordVariadic { .. } => {
                     let Some(self_keyword_variadic_type) = self_keyword_variadic else {
                         // For a `self <: other` relationship, if `other` has a keyword variadic
                         // parameter, `self` must also have a keyword variadic parameter.
-                        return false;
+                        return Err(TypeRelationError::todo());
                     };
-                    if !check_types(other_parameter.annotated_type(), self_keyword_variadic_type) {
-                        return false;
-                    }
+                    check_types(other_parameter.annotated_type(), self_keyword_variadic_type)?;
                 }
                 _ => {
                     // This can only occur in case of a syntax error.
-                    return false;
+                    return Err(TypeRelationError::todo());
                 }
             }
         }
@@ -911,11 +938,11 @@ impl<'db> Signature<'db> {
         // optional otherwise the subtype relation is invalid.
         for (_, self_parameter) in self_keywords {
             if self_parameter.default_type().is_none() {
-                return false;
+                return Err(TypeRelationError::todo());
             }
         }
 
-        true
+        Ok(())
     }
 
     /// Create a new signature with the given definition.
diff --git a/crates/ty_python_semantic/src/types/subclass_of.rs b/crates/ty_python_semantic/src/types/subclass_of.rs
index 5b12ae252..ed343b085 100644
--- a/crates/ty_python_semantic/src/types/subclass_of.rs
+++ b/crates/ty_python_semantic/src/types/subclass_of.rs
@@ -3,7 +3,7 @@ use ruff_python_ast::name::Name;
 use crate::place::PlaceAndQualifiers;
 use crate::types::{
     ClassType, DynamicType, KnownClass, MemberLookupPolicy, Type, TypeMapping, TypeRelation,
-    TypeTransformer, TypeVarInstance,
+    TypeRelationError, TypeTransformer, TypeVarInstance,
 };
 use crate::{Db, FxOrderSet};
 
@@ -148,21 +148,35 @@ impl<'db> SubclassOfType<'db> {
         db: &'db dyn Db,
         other: SubclassOfType<'db>,
         relation: TypeRelation,
-    ) -> bool {
+    ) -> Result<(), TypeRelationError> {
         match (self.subclass_of, other.subclass_of) {
             (SubclassOfInner::Dynamic(_), SubclassOfInner::Dynamic(_)) => {
-                relation.is_assignability()
+                if relation.is_assignability() {
+                    Ok(())
+                } else {
+                    Err(TypeRelationError::todo())
+                }
             }
             (SubclassOfInner::Dynamic(_), SubclassOfInner::Class(other_class)) => {
-                other_class.is_object(db) || relation.is_assignability()
+                if other_class.is_object(db) || relation.is_assignability() {
+                    Ok(())
+                } else {
+                    Err(TypeRelationError::todo())
+                }
+            }
+            (SubclassOfInner::Class(_), SubclassOfInner::Dynamic(_)) => {
+                if relation.is_assignability() {
+                    Ok(())
+                } else {
+                    Err(TypeRelationError::todo())
+                }
             }
-            (SubclassOfInner::Class(_), SubclassOfInner::Dynamic(_)) => relation.is_assignability(),
 
             // For example, `type[bool]` describes all possible runtime subclasses of the class `bool`,
             // and `type[int]` describes all possible runtime subclasses of the class `int`.
             // The first set is a subset of the second set, because `bool` is itself a subclass of `int`.
             (SubclassOfInner::Class(self_class), SubclassOfInner::Class(other_class)) => {
-                self_class.has_relation_to(db, other_class, relation)
+                self_class.try_has_relation_to(db, other_class, relation)
             }
         }
     }
diff --git a/crates/ty_python_semantic/src/types/tuple.rs b/crates/ty_python_semantic/src/types/tuple.rs
index 268bd42d1..50814148b 100644
--- a/crates/ty_python_semantic/src/types/tuple.rs
+++ b/crates/ty_python_semantic/src/types/tuple.rs
@@ -22,8 +22,8 @@ use std::hash::Hash;
 
 use itertools::{Either, EitherOrBoth, Itertools};
 
-use crate::types::Truthiness;
 use crate::types::class::{ClassType, KnownClass};
+use crate::types::{Truthiness, TypeRelationError};
 use crate::types::{
     Type, TypeMapping, TypeRelation, TypeTransformer, TypeVarInstance, TypeVarVariance,
     UnionBuilder, UnionType, cyclic::PairVisitor,
@@ -234,7 +234,7 @@ impl<'db> TupleType<'db> {
         db: &'db dyn Db,
         other: Self,
         relation: TypeRelation,
-    ) -> bool {
+    ) -> Result<(), TypeRelationError> {
         self.tuple(db)
             .has_relation_to(db, other.tuple(db), relation)
     }
@@ -399,13 +399,24 @@ impl<'db> FixedLengthTuple<Type<'db>> {
         db: &'db dyn Db,
         other: &Tuple<Type<'db>>,
         relation: TypeRelation,
-    ) -> bool {
+    ) -> Result<(), TypeRelationError> {
         match other {
             Tuple::Fixed(other) => {
-                self.0.len() == other.0.len()
-                    && (self.0.iter())
-                        .zip(&other.0)
-                        .all(|(self_ty, other_ty)| self_ty.has_relation_to(db, *other_ty, relation))
+                if self.0.len() != other.0.len() {
+                    return Err(TypeRelationError::todo());
+                }
+                let results = self
+                    .0
+                    .iter()
+                    .zip(&other.0)
+                    .map(|(self_ty, other_ty)| self_ty.try_has_relation_to(db, *other_ty, relation))
+                    .collect::<Vec<_>>();
+
+                if results.iter().all(Result::is_ok) {
+                    Ok(())
+                } else {
+                    TypeRelationError::from_results(results)
+                }
             }
 
             Tuple::Variable(other) => {
@@ -414,24 +425,32 @@ impl<'db> FixedLengthTuple<Type<'db>> {
                 let mut self_iter = self.0.iter();
                 for other_ty in &other.prefix {
                     let Some(self_ty) = self_iter.next() else {
-                        return false;
+                        return Err(TypeRelationError::todo());
                     };
                     if !self_ty.has_relation_to(db, *other_ty, relation) {
-                        return false;
+                        return Err(TypeRelationError::todo());
                     }
                 }
                 for other_ty in other.suffix.iter().rev() {
                     let Some(self_ty) = self_iter.next_back() else {
-                        return false;
+                        return Err(TypeRelationError::todo());
                     };
                     if !self_ty.has_relation_to(db, *other_ty, relation) {
-                        return false;
+                        return Err(TypeRelationError::todo());
                     }
                 }
 
                 // In addition, any remaining elements in this tuple must satisfy the
                 // variable-length portion of the other tuple.
-                self_iter.all(|self_ty| self_ty.has_relation_to(db, other.variable, relation))
+                let results = self_iter
+                    .map(|self_ty| self_ty.try_has_relation_to(db, other.variable, relation))
+                    .collect::<Vec<_>>();
+
+                if results.iter().all(Result::is_ok) {
+                    Ok(())
+                } else {
+                    TypeRelationError::from_results(results)
+                }
             }
         }
     }
@@ -741,7 +760,7 @@ impl<'db> VariableLengthTuple<Type<'db>> {
         db: &'db dyn Db,
         other: &Tuple<Type<'db>>,
         relation: TypeRelation,
-    ) -> bool {
+    ) -> Result<(), TypeRelationError> {
         match other {
             Tuple::Fixed(other) => {
                 // The `...` length specifier of a variable-length tuple type is interpreted
@@ -756,7 +775,7 @@ impl<'db> VariableLengthTuple<Type<'db>> {
                 // length.
                 if relation == TypeRelation::Subtyping || !matches!(self.variable, Type::Dynamic(_))
                 {
-                    return false;
+                    return Err(TypeRelationError::todo());
                 }
 
                 // In addition, the other tuple must have enough elements to match up with this
@@ -765,23 +784,23 @@ impl<'db> VariableLengthTuple<Type<'db>> {
                 let mut other_iter = other.elements().copied();
                 for self_ty in self.prenormalized_prefix_elements(db, None) {
                     let Some(other_ty) = other_iter.next() else {
-                        return false;
+                        return Err(TypeRelationError::todo());
                     };
                     if !self_ty.has_relation_to(db, other_ty, relation) {
-                        return false;
+                        return Err(TypeRelationError::todo());
                     }
                 }
                 let suffix: Vec<_> = self.prenormalized_suffix_elements(db, None).collect();
                 for self_ty in suffix.iter().rev() {
                     let Some(other_ty) = other_iter.next_back() else {
-                        return false;
+                        return Err(TypeRelationError::todo());
                     };
                     if !self_ty.has_relation_to(db, other_ty, relation) {
-                        return false;
+                        return Err(TypeRelationError::todo());
                     }
                 }
 
-                true
+                Ok(())
             }
 
             Tuple::Variable(other) => {
@@ -799,26 +818,28 @@ impl<'db> VariableLengthTuple<Type<'db>> {
                 // The overlapping parts of the prefixes and suffixes must satisfy the relation.
                 // Any remaining parts must satisfy the relation with the other tuple's
                 // variable-length part.
-                if !self
+                let results = self
                     .prenormalized_prefix_elements(db, self_prenormalize_variable)
                     .zip_longest(
                         other.prenormalized_prefix_elements(db, other_prenormalize_variable),
                     )
-                    .all(|pair| match pair {
+                    .map(|pair| match pair {
                         EitherOrBoth::Both(self_ty, other_ty) => {
-                            self_ty.has_relation_to(db, other_ty, relation)
+                            self_ty.try_has_relation_to(db, other_ty, relation)
                         }
                         EitherOrBoth::Left(self_ty) => {
-                            self_ty.has_relation_to(db, other.variable, relation)
+                            self_ty.try_has_relation_to(db, other.variable, relation)
                         }
                         EitherOrBoth::Right(_) => {
                             // The rhs has a required element that the lhs is not guaranteed to
                             // provide.
-                            false
+                            Err(TypeRelationError::todo())
                         }
                     })
-                {
-                    return false;
+                    .collect::<Vec<_>>();
+
+                if !results.iter().all(Result::is_ok) {
+                    return TypeRelationError::from_results(results);
                 }
 
                 let self_suffix: Vec<_> = self
@@ -827,27 +848,31 @@ impl<'db> VariableLengthTuple<Type<'db>> {
                 let other_suffix: Vec<_> = other
                     .prenormalized_suffix_elements(db, other_prenormalize_variable)
                     .collect();
-                if !(self_suffix.iter().rev())
+
+                let results = (self_suffix.iter().rev())
                     .zip_longest(other_suffix.iter().rev())
-                    .all(|pair| match pair {
+                    .map(|pair| match pair {
                         EitherOrBoth::Both(self_ty, other_ty) => {
-                            self_ty.has_relation_to(db, *other_ty, relation)
+                            self_ty.try_has_relation_to(db, *other_ty, relation)
                         }
                         EitherOrBoth::Left(self_ty) => {
-                            self_ty.has_relation_to(db, other.variable, relation)
+                            self_ty.try_has_relation_to(db, other.variable, relation)
                         }
                         EitherOrBoth::Right(_) => {
                             // The rhs has a required element that the lhs is not guaranteed to
                             // provide.
-                            false
+                            Err(TypeRelationError::todo())
                         }
                     })
-                {
-                    return false;
+                    .collect::<Vec<_>>();
+
+                if !results.iter().all(Result::is_ok) {
+                    return TypeRelationError::from_results(results);
                 }
 
                 // And lastly, the variable-length portions must satisfy the relation.
-                self.variable.has_relation_to(db, other.variable, relation)
+                self.variable
+                    .try_has_relation_to(db, other.variable, relation)
             }
         }
     }
@@ -1080,7 +1105,12 @@ impl<'db> Tuple<Type<'db>> {
         }
     }
 
-    fn has_relation_to(&self, db: &'db dyn Db, other: &Self, relation: TypeRelation) -> bool {
+    fn has_relation_to(
+        &self,
+        db: &'db dyn Db,
+        other: &Self,
+        relation: TypeRelation,
+    ) -> Result<(), TypeRelationError> {
         match self {
             Tuple::Fixed(self_tuple) => self_tuple.has_relation_to(db, other, relation),
             Tuple::Variable(self_tuple) => self_tuple.has_relation_to(db, other, relation),
